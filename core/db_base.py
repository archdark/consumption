'''
File: db_base.py
Author: Konrad Wasowicz
Description: BaseDBHandler --- implements basic database interaction methods
'''

import logging
from config import *
from models import users, bought_products, products, engine
from sqlalchemy.sql import select, exists
from sqlalchemy.sql import and_, or_, not_
from sqlalchemy import desc

logging.basicConfig(filename = ROOT_PATH + "/errors.log", level = logging.DEBUG)

class BaseDBHandler(object):


    """
    Implements basic functions for database interaction.
    """


    def parse_query_data(self, query, iter):
        """
        Parses tuple returned from database by sqlalchemy,  
        second argument is iterable list or tuple containing database
        field names minus primary key
        
        Keyword Arguments:
        query -- tuple with data returned from db (tuple/list),
        iter -- iterable containing field names used for parsing database
        info (list/tuple)
        """
        if type(iter) not in (tuple, list):
            raise TypeError("iter must be iterable type : list or tuple")
        if not query:
            return dict()
        return dict(zip(iter, query[1:]))

    def parse_list_query_data(self, data, iter):
        """
        Parses list of tuples returned from db by sqlalchemy,
        Returns dictionary containing:
            user_uuid: { user_data_returned by parse_query_data }
        
        Keyword Arguments:
        data -- tuple containing tuples :) returned from db (list/tuple),
        iter -- iterable containg field names for given table (minus pk)

        """
        result = dict()
        for row in data:
            temp = self.parse_query_data(row, iter)
            result[temp["uuid"]] = temp
        return result

    def generate_unique_uuid(self, field_name):
        """
        Generates unique 36 characters long uuid 
        (generated by uuid.uuid4 module)
        
        Keyword Arguments:
        field_name -- column name in sqlalchemy expression language format
        to compare to, eg. users.c.user_uuid (sqlalchemy column name)
        """
        while True:
            uuid = str(uuid.uuid4())
            sel = select([exists().where(field_name == uuid)])
            result = self.conn.execute(sel).scalar()
            if result == 0:
                return uuid
    
    def get_row(self, column, uuid, field_tuple):
        """
        Returns dictionary containg single row data returned from db
        
        Keyword Arguments:
        column -- sqlalchemy column name (eg. users.c.username)
        uuid -- unique uuid (str)
        field_tuple - iterable containing fields to parse dictionary against (list/tuple)
        """
        sel = select([users]).where(column == uuid)
        q = self.conn.execute(sel).fetchone()
        if not q:
            return dict()
        return self.parse_query_data(q, field_tuple)

    def get_all_rows(self, table, field_tuple, limit, offset):
        """
        Returns dictionary containing list of rows returned from table,
        see parse_list_query_data for structure of the dict
        
        Keyword Arguments:
        table -- tablename to get data from (sqlalchemy table)
        field_tuple -- iterable to parse dictionary against (list/tuple)
        limit -- limit the number of rows returned (int)
        offset -- offset for query (int)
        """
        sel = select([table]).limit(limit).offset(offset)
        res = self.conn.execute(sel).fetchall()
        return self.parse_list_query_data(res, field_tuple)

    def check_exists(self, column, value):
        """
        Checks if given value exists in table 
        
        Keyword Arguments:
        column -- sqlalchemy expression language column (eg. users.c.username)
        value -- value to search for (str)
        """
        sel = select([exists().where(column == value)])
        result = self.conn.execute(sel).scalar()
        return result

    def delete_row(self, column, value):
        """
        Deletes row that matches value 
        
        Keyword Arguments:
        column -- sqlalchemy column to search in
        value -- value to match it against
        """
        delete_q = users.delete().where(column == value)
        self.conn.execute(delete_q)


class UserDatabaseHandler(BaseDBHandler):

    """
    Base class for user database interaction
    accepts connection object as argument
    defaults to self.application.conn
    """

        
    def __init__(self, conn = None):
        if conn:
            self.conn = conn

        else:
            self.conn = self.application.conn

    def user_exists(self, uuid):
        """
        Checks if user with given uuid exists 
        """
        return self.check_exists(users.c.user_uuid, uuid)

    def credentials_unique(self, username, email):
        """
        Checks if given credentials are already taken
        
        Keyword Arguments:
        username, email -- (str)
        Returns : bool
        """
        sel = select([exists().where(
                or_(
                    users.c.username == username,
                    users.c.email == email
                )
        )])
        result = self.conn.execute(sel).scalar()
        return not result

    def save_user(self, data):
       """
       Create new user with given data
       
       Keyword Arguments:
       data -- dictionary containing user field names,
       must have all the keys in USER_FIELDS,
       all additional keys all discarded
       """
       els_to_insert = dict()
       for key, value in data.items():
           if key in USER_FIELDS:
               els_to_insert[key] = value
       for field in USER_FIELDS:
           if field not in els_to_insert.keys():
               raise Exception("Data not parsed properly, missing {0}".format(field))
       els_to_insert["user_uuid"] = els_to_insert["uuid"] # i screwed up :(
       del els_to_insert["uuid"]
       ins = users.insert().values(**els_to_insert)
       self.conn.execute(ins)

    def get_user(self, uuid):
        """
        Get user with given uuid 
        
        Keyword Arguments:
        uuid -- unique user uuid
        """
        return self.get_row(users.c.user_uuid, uuid, USER_FIELDS)

    def delete_user(self, uuid):
        """
        Deletes user with given uuid 
        
        Keyword Arguments:
        uuid -- unique users uuid
        """
        self.delete_row(users.c.uuid, uuid)

    def update_user(self, uuid, data):
        """
        Updates user values with given data
        
        Keyword Arguments:
        uuid -- unique user\'s uuid,
        data -- dictionary containg {field_name : value} (dict)
        """
        items_to_update = dict()
        for key, value in data.items():
            if key in CUSTOM_USER_FIELDS:
                items_to_update[key] = value
        update_q = users.update()\
                .where(users.c.user_uuid == uuid)\
                .values(**items_to_update)
        self.conn.execute(update_q)

    def list_all_users(self, limit, offset):

        """
        Returns list of users from db 
        limit -- limit amount of rows returned (int),
        offset -- offset for a query (int)
        """

        return self.get_all_rows(users, USER_FIELDS, limit, offset)


    def get_user_products(self, uuid):

        """
        Return tuple containing list of all items bought by user 

        Keyword Arguments:
        uuid -- user uniquye uuid (str)
        
        """

        sel = select([users.c.user_id]).where(users.c.user_uuid == uuid)
        user_id = self.conn.execute(sel).fetchone()[0]
        if not user_id:
            return dict()
        user_products = select([products, bought_products.c.quantity])\
                .select_from(products.join(bought_products))\
                .where(bought_products.c.user_id == user_id)\
                .order_by(desc(bought_products.c.quantity))

        return self.conn.execute(user_products).fetchall()

    def increase_bought_qty(self, amount, id):
        """
        Increases given product quantity
        accepts bought products id, and amount to add

        Keyword Arguments:
        amount -- amount to increase (int),
        id -- unique bought_item primary key (int)
        """
        current = self.conn.execute(select([bought_products.c.quantity])\
                                    .where(bought_products.c.bought_id == id))\
                                    .scalar() # get current amount
        update = bought_products.update()\
                .where(bought_products.c.bought_id == id)\
                .values(quantity = (current + amount))
        self.conn.execute(update)


    def check_user_bought_product(self, user_uuid, product_uuid):

        """
        Returns Falsy value if user has not bought product with given uuid else returns 
        bought product\'s id
        
        Keyword Arguments:
        user_uuid -- unique user\'s uuid,
        product_uuid -- unique product\'s uuid
        """

        sel = select([users.c.user_id]).where(users.c.user_uuid == user_uuid)

        user = self.conn.execute(sel).fetchone()

        if not user:
            return None

        sel = select([bought_products.c.bought_id]).select_from(products.join(bought_products))\
                .where(and_(products.c.product_uuid == product_uuid,\
                            bought_products.c.user_id == user[0] ))
        res = self.conn.execute(sel).scalar()
        return res

    def create_bought_product(self, qty, user_uuid, product_uuid):

        """
        Create new bought item given product_uuid and user_uuid 
        of product or user with given uuid doesnt exists returns None
        
        Keyword Arguments:
        qty -- amount of items bought (int),
        user_uuid -- unique user uuid (str),
        product_uuid -- unique product uuid (str)
        """

        user_id = self.conn.execute(select([users.c.user_id]).where(users.c.user_uuid == user_uuid)).scalar()
        product_id = self.conn.execute(select([products.c.product_id]).where(products.c.product_uuid == product_uuid)).scalar()
        if product_id and user_id:
            ins = bought_products.insert().values(quantity = qty, user_id = user_id, product_id = product_id)
            self.conn.execute(ins)
        else:
            return


    def add_bought_product(self, quantity, user_uuid, product_uuid):

        """
        Wrapper for create_bought_product, and increase_bought_quantity,
        if item is already bought by user increase quantity
        else create new record.
        
        Keyword Arguments:
        quantity -- amount of items bought (int),
        user_uuid -- unique user uuid (str),
        product_uuid -- unique product uuid (str)

        """
       
        bought = self.check_user_bought_product(user_uuid, product_uuid) # check if user bought item 
        if bought:
            self.increase_bought_qty(quantity, bought) # if yes increase quantity
        else:
            self.create_bought_product(quantity, user_uuid, product_uuid) # else create new record

    def _delete_all_users(self):
        """
        Deletes all users from db,
        use at your own risk
        """
        del_all = users.delete()
        self.conn.execute(del_all)

class ProductDatabaseHandler(BaseDBHandler):

    """
    Base class for product database interaction
    accepts optional conn argument which should be a connection object
    to sqlalchemy db
    """

    def __init__(self, conn = None):
        if conn:
            self.conn = conn

        else:
            self.conn = self.application.conn

    def generate_product_uuid(self):
        """
        Generates unique product uuid 
        """
        return self.generate_unique_uuid(products.c.product_uuid)


    def product_exists(self, uuid):
        """
        Checks if product with given uuid exists in db 
        """
        return self.check_exists(products.c.product_uuid, uuid)

    def save_product(self, data):
       """
       Create new product with given data
       
       Keyword Arguments:
       data -- dictionary containing product field names,
       must have all the keys in PRODUCT_FIELDS,
       all additional keys all discarded
       """
       els_to_insert = dict()
       for key, value in data.items():
           if key in PRODUCT_FIELDS:
               els_to_insert[key] = value
       for field in PRODUCT_FIELDS:
           if field not in els_to_insert.keys():
               raise Exception("Data not parsed properly, missing {0}".format(field))
       els_to_insert["product_uuid"] = els_to_insert["uuid"]
       del els_to_insert["uuid"]
       self.conn.execute(products.insert().values(**els_to_insert))


    def get_product(self, uuid):
        """
        Get product with given uuid 
        """

        return self.get_row(products.c.product_uuid, uuid)



    def delete_product(self, uuid):
        """
        Delete product with given uuid 
        """
        self.delete_row(products.c.product_uuid, uuid)

    def update_product(self, uuid, data):
        """
        Update product with given uuid 
        
        Keyword Arguments:
        uuid -- string containing unique product uuid (str)
        data -- dictionary containing fields to be updated,
                it is matched against CUSTOM_USER_FIELDS and 
                only those fields specified there will be modified
        """

        items_to_update = dict()
        for key, value in data.items():
            if key in CUSTOM_PRODUCT_FIELDS:
                items_to_update[key] = value
        update_q = products.update().where(products.c.product_uuid == uuid).values(**items_to_update)
        self.conn.execute(update_q)


    def list_all_products(self, limit, offset):
        """
        Get a dictionary of products returned from db 
        Returns: dict
        
        Keyword Arguments:
        limit, offset -- int

        """
        return self.get_all_rows(products, PRODUCT_FIELDS, limit, offset)

    def get_top_selling_products(self, limit=10):
        """
        Returns list of most selled products
        limit -- (optional) limit the results, defaults to 10
        """
        sel = select([func.sum(bought_products.c.quantity).label("suma"), products.c.product_name])\
                .select_from(products.join(bought_products))\
                .group_by(bought_products.c.product_id)\
                .order_by(desc("suma")).limit(limit)

        top_products = self.conn.execute(sel).fetchall()

        result = dict()
        for product_item in top_products:
            result[product_item[1]] = product_item[0]
        return result

    def get_all_sold_products(self, limit = None):

        """
        Return list of all items sold 
        limit -- (optional) (int)
        """

        sel = select([products]).select_from(products.join(bought_products)).group_by(bought_products.c.product_id)

        if limit:
            return self.conn.execute(sel.limit(limit)).fetchall()
        else:
            return self.conn.execute(sel).fetchall()

    def _delete_all_products(self):
        """
        Deletes all the products 
        """
        del_all = products.delete()
        self.conn.execute(del_all)

